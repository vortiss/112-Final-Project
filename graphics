import javax.swing.JPanel;
import javax.swing.JFrame;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Dimension;
import java.util.Random;
import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;

public class Frogger extends JPanel implements KeyListener{
	public static final int WIDTH = 1024;
	public static final int HEIGHT = 768;
	public static final int FPS = 60;
	World world;
	
	class Runner implements Runnable{
		public void run(){
			while(true){
				world.updateState(1.0 / (double)FPS);
				repaint();
				try{
				    Thread.sleep(1000/FPS);
				}
				catch(InterruptedException e){}
			}
			
		}
	    
	}
	
	public void keyPressed(KeyEvent e) {
		commands(e);
    	}
    
	public void addNotify() {
		super.addNotify();
		requestFocus();
  	}
    
	public void commands(KeyEvent e){
		char c=e.getKeyChar();
		if(c=='w'||c=='a'||c=='s'||c=='d'){
	 	   userObject.move(c,world);
		}
		if(c=='r'){
			this=new Frogger;
		}
		if(c=='q'){
			System.exit(0);
		}
    	}
    
   	public Frogger(){
		world = new World(WIDTH, HEIGHT,16,16);
		addKeyListener(this);
		this.setPreferredSize(new Dimension(WIDTH, HEIGHT));
		Thread mainThread = new Thread(new Runner());
		mainThread.start();
    	}
    
    	public static void main(String[] args){
		JFrame frame = new JFrame("Frogger+");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Frogger mainInstance = new Frogger();
		frame.setContentPane(mainInstance);
		frame.pack();
		frame.setVisible(true);
   	}
    
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		world.zone.build(1,g);
		world.drawObstacles(g);
		world.drawLogs(g);
		world.drawUserObject;
	
    	}
}

class World{
    	static int height;
    	static int width;
    	int numObstacles;
    	Obstacle obstacles[];
   	environmentalObjects logs[];
   	Terrain zone;
    	userObject player;
    	Pair position[];
    	Pair positionlogs[];
    	userObject frog;
   
    	public World(int initWidth, int initHeight,int numObstacle, int numLog){
		position[] = new Pair[numObstacle];
		positionlogs[] = newPair[numLog];
		obstacles=new Obstacle[numObstacle];
		logs = new environmentalObjects[numLog];
		frog = new userObject;
		
		for (int i=0; i<numObstacle/4 i++){
		    position[i] = (0, height/36*(4) + 9*i);   
		}
		for (int i = numObstacle/4; i < numObstacle/2; i++){
			position[i] = (0,height/36*5 + 9*i)
		}
		for (int i = numObstacle/2; i < numObstacle*3/4; i++){
			position[i] = (width, height/36*4 + 9*i);	
		}
		for (int i = numObstacle*3/4; i<numObstacle; i++){
			position[i] = (width, height/36*5 + 9*i);
		}
		
		for (int i=; i<numLog/4 i++){
		    positionlogs[i] = (0, height/36*(7) + 9*i);   
		}
		for (int i = numLog/2; i < numObstacle/2; i++){
			positionlogs[i] = (0,height/36*8 + 9*i)
		}
		for (int i = numObstacle/2; i < numObstacle*3/4; i++){
			positionlogs[i] = (width, height/36*7 + 9*i);	
		}
		for (int i = numObstacle*3/4; i<numObstacle; i++){
			positionlogs[i] = (width, height/36*8 + 9*i);
		}
		
		
		width = initWidth;
		height = initHeight;
		
		for(int i=0; i < numObstacle;i++){
			if (i < numObstacle / 2)
				obstacles[i]=new Obstacle(position[i], 1);
		}
		if (i > numObstacle/2)
		    obstacles[i] = new Obstacle(position[i], 0);
    		}
    
    		for(int i=0; i < numLog; i++){
			if (i < numLog / 2)
	    		logs[i]=new environmentalObject(position[i], 1);
		}
		if (i > numLog/2)
	    		logs[i] = new environmentalObject(position[i], 0);
    }
    
    public void gameOver(Graphics g){ 
    		g.setColor(0,0,0);
		g.drawRect(0,0,width,height);
		g.setColor(202,13,13);
		g.printString("You died not once, not twice, but thrice. Press R to try again.", (width/2)-63, height/2);
    }
    
    public boolean incontact(){
    		for (int i = 0; i < numLog; i++){
    			if (((frog.x <= (logs[i].position.x + logs[i].size.x)) && (frog.x >= logs[i].position.x) && 
    (frog.y >= logs[i].position.y) && (frog.y <= (logs[i].position.y + logs[i].size.y)) || 
    (((frog.x + frog.width) <= (logs[i].position.x + logs[i].size.x)) && ((frog.x + frog.width) >= logs[i].position.x)
    && (frog.y >= logs[i].position.y) && (frog.y <= (logs[i].position.y + logs[i].size.y)))
    				return true;
    		}
    		else {return false;}

    }
    
    public environmentalObject contactLog(){
   		for (int i = 0; i < numLog; i++){
			if (((frog.x <= (logs[i].position.x + logs[i].size.x)) && (frog.x >= logs[i].position.x) && 
    (frog.y >= logs[i].position.y) && (frog.y <= (logs[i].position.y + logs[i].size.y)) || 
    (((frog.x + frog.width) <= (logs[i].position.x + logs[i].size.x)) && ((frog.x + frog.width) >= logs[i].position.x)
    && (frog.y >= logs[i].position.y) && (frog.y <= (logs[i].position.y + logs[i].size.y)))
    
   			 	return logs[i];
   	 	}
    
    }
    
    
    public void updateState(){
		for (int i = 0; i < numObstacles; i++){	
	    		obstacles[i].update(this);
	    		if incontact(){
	    		frog.position.x = contactLog().position.x;
	    		frog.position.y = contactLog().position.y;   
	   	}
	}
	stillAlive(this);
	
    }
    public void drawObstacles(Graphics g){
	for(int i=0;i<numObstacle;i++){
	    obstacles[i].draw(g);
	}	
    }
    
    public void drawLogs(Graphics g){
    	for (int i = 0; i < numLog; i ++){
    		logs[i].draw(g);
    	}
    }
    
    public void drawUserObject(Graphics g){
	    frog.draw(g);
    }
    
}
