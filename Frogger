import javax.swing.JPanel;
import javax.swing.JFrame;
import java.awt.*;
import java.util.Random;
import javax.imageio.ImageIO;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.FileSystems;
import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;

public class Frogger extends JPanel implements KeyListener{
    public static final int WIDTH = 1024;
    public static final int HEIGHT = 768;
    public static final int FPS = 60;
    World world;
    public static  DrawImage imageFinder;
    
    class Runner implements Runnable{
	public void run(){
	    while(true){ // keeps the program running
		world.updateState();
		repaint();
		try{
		    Thread.sleep(1000/FPS);
		}
		catch(InterruptedException e){}
	    }
	    
	}
	
    }
    
    public void keyPressed(KeyEvent e) {
	commands(e);
    }
    
    public void addNotify() {
	super.addNotify();
	requestFocus();
    }
    public void keyReleased(KeyEvent e){
	
    }
    
    public void keyTyped(KeyEvent e){
	
    }
    public void commands(KeyEvent e){
	char c=e.getKeyChar();
	if(c=='w'||c=='a'||c=='s'||c=='d')
	    userObject.move(c,world); // frogger moves up down left or right according to the key pressed
	if(c=='l'){			
	    System.out.println("Thanks for playing!");			
	    System.exit(0);
	}
    }
    
    public Frogger(){
	world = new World(WIDTH, HEIGHT,16,16,this); // creates the world
	addKeyListener(this);
	this.setPreferredSize(new Dimension(WIDTH, HEIGHT));
	Thread mainThread = new Thread(new Runner());
	mainThread.start();
    }
    
    public static void main(String[] args){
	JFrame frame = new JFrame("Frogger+");
	imageFinder=new DrawImage();
	frame.add(imageFinder);
	frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	Frogger mainInstance = new Frogger();
	frame.setContentPane(mainInstance);
	frame.pack();
	frame.setVisible(true);
    }
    @Override
	public void paintComponent(Graphics g) {
	super.paintComponent(g);
	for (int i = 0; i < 12; i++){ // creates alternating rows of 3 diff types
	    if (i % 3 == 2)
		g.setColor(Color.GREEN);
	    if (i % 3 == 1) 	
		g.setColor(Color.GRAY);
	    if(i % 3 == 0)
		g.setColor(Color.BLUE);	
	    
	    g.fillRect(0,(i-1)*world.height/12, world.width, world.height/12);
	    
	}
	world.drawLogs(g);
	world.drawObstacles(g);
	userObject.draw(g,world);
	
    }
}

class World{
    static int height;
    static int  width;
    int numObstacles;
    int numLog;
    Obstacle[] obstacles;
    environmentalObjects[] logs;
    Terrain zone;
    userObject player;
    Pair[] position;
    Pair[] positionlogs;
    userObject frog;
    Frogger gameRunning;
    
    public World(int initWidth, int initHeight,int numObstacle, int numLog, Frogger game){
	gameRunning=game;
	position = new Pair[numObstacle];
	positionlogs = new Pair[numLog];
	obstacles=new Obstacle[numObstacle];
	logs = new environmentalObjects[numLog];
	frog = new userObject(this);
	width=initWidth;
	height=initHeight;	

	for (int i=0; i<numObstacle/4;i++){
	    position[i] =new Pair(0,0);   
	}
	for (int i = numObstacle/4; i < numObstacle/2; i++){
	    position[i] =new Pair(0,192);
	}
	for (int i = numObstacle/2; i < numObstacle*3/4; i++){
	    position[i] =new Pair(width,4*height/36 +9*i);	
	}
	for (int i = numObstacle*3/4; i<numObstacle; i++){
	    position[i] =new Pair (width,5*height/36 + 9*i);
	}
	for (int i= 0; i<numLog/4;i++){
	    positionlogs[i] =new Pair (0, 7*height/36 + 9*i);   
	}
	for (int i = numLog/4; i < numLog/2; i++){
	    positionlogs[i] =new Pair (0, 8*height/36 + 9*i);
	}
	for (int i = numLog/2; i < numLog*3/4; i++){
	    positionlogs[i] =new Pair (width, 7*height/36 + 9*i);	
	}
	for (int i = numLog*3/4; i<numLog; i++){
	    positionlogs[i] =new Pair (width, height/36*8 + 9*i);
	}
	// the above for loops establish the initial positions of the obstacles and logs
	
	for(int i=0; i < numObstacle;i++){
	    if (i < numObstacle / 2)
		obstacles[i]=new Obstacle(position[i], 1);
	    if (i >= numObstacle/2)
		obstacles[i] = new Obstacle(position[i], 0);
	}
	// assigns the position to the obstacles
	
	for(int i=0; i < numLog; i++){
	    if (i < numLog / 2)
		logs[i]=new environmentalObjects(position[i], 1);
	    if (i >= numLog/2)
		logs[i] = new environmentalObjects(position[i], 0);

	}
	
	// assigns the position to the logs
    }
    
    public static void gameOver(Graphics g){ 
	g.setColor(Color.BLACK);
	g.drawRect(0,0,width,height);
	g.setColor(new Color(202,13,13));
	g.drawString("You died not once, not twice, but thrice. Press p to play again or l to leave", (width/2)-63, height/2);
    	
	boolean decision=false;
	while(!decision){
	    try{
		Thread.sleep(3000);
	    }
	    catch(InterruptedException e){}
	}
    }
    
    public boolean incontact(){
	for (int i = 0; i < numLog; i++){
	    if ((frog.position.x<=(logs[i].position.x+logs[i].size.x)&&frog.position.x>=logs[i].position.x&&frog.position.y>=logs[i].position.y&&frog.position.y<=(logs[i].position.y+logs[i].size.y))||((frog.position.x+frog.width)<=(logs[i].position.x+logs[i].size.x)&&(frog.position.x+frog.width)>=logs[i].position.x&&frog.position.y>=logs[i].position.y&&frog.position.y<=(logs[i].position.y+logs[i].size.y)))
		return true; // determines if frog is in contact with a log
	}
	return false;
	
    }
    
    public environmentalObjects contactLog(){
	for (int i = 0; i < numLog; i++){
	    if ((frog.position.x<=(logs[i].position.x+logs[i].size.x)&&frog.position.x>=logs[i].position.x&&frog.position.y>=logs[i].position.y&&frog.position.y<=(logs[i].position.y+logs[i].size.y))||((frog.position.x+frog.width)<=(logs[i].position.x+logs[i].size.x)&&(frog.position.x+frog.width)>=logs[i].position.x&&frog.position.y>=logs[i].position.y&&frog.position.y<=(logs[i].position.y+logs[i].size.y)))
		
		return logs[i]; // returns the log that the frog is in contact with
	}
        return null;
	
    }
    
    public void updateState(){
	for (int i = 0; i < numObstacles; i++){	
	    obstacles[i].update(this);
	    logs[i].update(this);
	    if (incontact()){
		frog.position.x = frog.position.x + contactLog().speed; // updates the state of logs, obstacles, and frog (if it is in contact 
		with a log)
	    }
	}	
	frog.stillAlive(this);
	
	
    }
    
    public void drawObstacles(Graphics g){
	for(int i=0;i<numObstacles;i++){
	    obstacles[i].draw(g,this);
	}	
    }
    
    public void drawLogs(Graphics g){
	for (int i = 0; i < numLog; i ++){
	    logs[i].draw(g,this);
	}
    }
    
}

class DrawImage extends JPanel{
    static Image picture;
    static Toolkit kit;
    
    public DrawImage(){
	kit=Toolkit.getDefaultToolkit();
	picture=null;
    }
    
    public static void changePicture(String pictureName){
	try{
	    picture=ImageIO.read(new File(pictureName+".png"));
	}
	catch(Exception e){
	    System.out.println("Fishsticks! "+e+"\t"+pictureName);
	}
    }
}
